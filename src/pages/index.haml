#intro
  %p
    Handlebars 为你提供了一个可以毫无挫折感的高效率书写 <strong>语义化的模板</strong> 所必需的一切。

  %p
    Mustache 模板和 Handlebars 是兼容的，所以你可以把Mustache模板拿来导入到Handlebars中，并开始使用Handlebars所提供的更丰富的功能。

    <a href="https://github.com/wycats/handlebars.js#differences-between-handlebarsjs-and-mustache">here</a>.

= link("安装下载", "installation.html", :class => 'download')

%h2#getting-started
  快速开始

.contents
  .bullet
    .description
      Handlebars模板看起来就像是正常的Html，并使用了嵌入的 handlebars 表达式。
    :html
      <div class="entry">
        <h1>{{title}}</h1>
        <div class="body">
          {{body}}
        </div>
      </div>
    .notes
     handlebars表达式，是以 <code>{{</code> 开始，跟一些内容，然后以  <code>}}</code> 结束。
      A handlebars expression is a <code>{{</code>, some contents,
    = link("更多资料：表达式", "expressions.html", :class => "more-info")

  .bullet
    .description
      你可以通过<code>&lt;script&gt;</code>标签把一段模板加载到浏览器中。
    :html
      <script id="entry-template" type="text/x-handlebars-template">
        <div class="entry">
          <h1>{{title}}</h1>
          <div class="body">
            {{body}}
          </div>
        </div>
      </script>

  .bullet
    .description
      在 JavaScript 中使用 <code>Handlebars.compile</code> 来编译模板。

    :javascript
      var source   = $("#entry-template").html();
      var template = Handlebars.compile(source);
    .notes
      还可以预编译模板。这样的话，就只需要一个更小的运行时库文件，并且对性能来说是一个极大的节约，因为这样就不必在浏览器中编译模板了。这点在移动版的开发中就更显的非常重要了。
    = link("更多资料：预编译", "precompilation.html", :class => "more-info")

  .bullet
    .description
      只需传递一个上下文context执行模板，即可得到返回的 HTML 的值。
    :javascript
      var context = {title: "My New Post", body: "This is my first post!"};
      var html    = template(context);
    .notes
      得到下面的HTML
    :html
      <div class="entry">
        <h1>My New Post</h1>
        <div class="body">
          This is my first post!
        </div>
      </div>

    = link("更多资料：执行", "execution.html", :class => "more-info")

%h2#html-escaping
  HTML Escaping

.context
  .bullet
    .description
      Handlebars的 <code>{{expression}}</code>表达式会返回一个 HTML编码 HTML-escape 过的值。如果不希望Handlebars来编码这些值，使用三个大括号即可：<code>{{{</code>。
    :html
      <div class="entry">
        <h1>{{title}}</h1>
        <div class="body">
          {{{body}}}
        </div>
      </div>

    .notes
      使用这段上下文（数据）：

    :javascript
      {
        title: "All about <p> Tags",
        body: "<p>This is a post about &lt;p&gt; tags</p>"
      }

    .notes
      会得到如下结果：

    :html
      <div class="entry">
        <h1>All About &lt;p&gt; Tags</h1>
        <div class="body">
          <p>This is a post about &lt;p&gt; tags</p>
        </div>
      </div>

    .notes

      Handlebars 不会再对 <code>Handlebars.SafeString</code> 安全字符串进行编码。如果你写的 helper 用来生成 HTML，就经常需要返回一个 <code>new Handlebars.SafeString(result)</code>。在这种情况下，你就需要手动的来编码参数了。

    :javascript
      Handlebars.registerHelper('link', function(text, url) {
        text = Handlebars.Utils.escapeExpression(text);
        url  = Handlebars.Utils.escapeExpression(url);

        var result = '<a href="' + url + '">' + text + '</a>';

        return new Handlebars.SafeString(result);
      });

    .notes
      这样来编码传递进来的参数，并把返回的值标记为 安全，这样的话，即便不是哟给你“三个大括号”，Handlebars 就不会再次编码它了。

%h2#block-expressions
  块级表达式

.context
  .bullet
    .description
      块级表达式允许你定义一个helpers，并使用一个不同于当前的上下文（context）来调用你模板的一部分。现在考虑下这种情况，你需要一个helper来生成一段 HTML 列表：

    .notes
      并使用下面的上下文（数据）：

    :html
      {{#list people}}{{firstName}} {{lastName}}{{/list}}

    .notes
      并使用下面的上下文（数据）：

    :javascript
      {
        people: [
          {firstName: "Yehuda", lastName: "Katz"},
          {firstName: "Carl", lastName: "Lerche"},
          {firstName: "Alan", lastName: "Johnson"}
        ]
      }

    .notes
      此时需要创建一个 名为 <code>list</code>  的 helper 来生成这段 HTML 列表。这个 helper 使用 people 作为第一个参数，还有一个 options 对象（hash哈希）作为第二个参数。这个 options 对象有一个叫 fn 的属性，你可以传递一个上下文给它（fn），就跟执行一个普通的 Handlebars 模板一样：


    :javascript
      Handlebars.registerHelper('list', function(items, options) {
        var out = "<ul>";

        for(var i=0, l=items.length; i<l; i++) {
          out = out + "<li>" + options.fn(items[i]) + "</li>";
        }

        return out + "</ul>";
      });

    .notes
      执行之后，这个模板就会渲染出：

    :html
      <ul>
        <li>Yehuda Katz</li>
        <li>Carl Lerche</li>
        <li>Alan Johnson</li>
      </ul>

    .notes
      块级的 helpers 还有很多其他的特性，比如可以创建一个 <code>else</code>  区块（例如，内置的 if helper 就是用 else）。

    .notes
      注意，因为在你执行 options.fn(context) 的时候，这个 helper 已经把内容编码一次了，所以 Handlebars 不会再对这个 helper 输出的值进行编码了。如果编码了，这些内容就会被编码两 次！

    = link("更多资料：块级Helpers", "block_helpers.html", :class => "more-info")

%h2#paths
  Handlebars 路径

.content
  .bullet
    .description
      Handlebars 支持简单的路径，就像Mustache那样。
    :html
      <p>{{name}}</p>

  .bullet
    .description
      Handlebars 同样也支持嵌套的路径，这样的话就可以在当前的上下文中查找内部嵌套的属性了。
    :html
      <div class="entry">
        <h1>{{title}}</h1>
        <h2>By {{author.name}}</h2>

        <div class="body">
          {{body}}
        </div>
      </div>
    .notes
      上面的模板使用下面这段上下文：
    :javascript
      var context = {
        title: "My First Blog Post!",
        author: {
          id: 47,
          name: "Yehuda Katz"
        },
        body: "My first post. Wheeeee!"
      };
    .notes
      This makes it possible to use Handlebars templates with
      more raw JSON objects.

  .bullet
    .description
      Nested handlebars paths can also include <code>../</code> segments,
      which evaluate their paths against a parent context.
    :html
      <h1>Comments</h1>

      <div id="comments">
        {{#each comments}}
        <h2><a href="/posts/{{../permalink}}\#{{id}}">{{title}}</a></h2>
        <div>{{body}}</div>
        {{/each}}
      </div>
    .notes
      Even though the link is printed while in the context of a comment,
      it can still go back to the main context (the post) to retrieve
      its permalink.
    .notes
      The exact value that <code>../</code> will resolve to varies based on the helper that is calling the block. Using <code>../</code> is only necessary when context changes, so children of helpers such as <code>each</code> would require the use of <code>../</code> while children of helpers such as <code>if</code> do not.

    :html
      {{permalink}}
      {{#each comments}}
        {{../permalink}}

        {{#if title}}
          {{../permalink}}
        {{/if}}
      {{/each}}

    .notes
      In this example all of the above reference the same <code>permalink</code> value even though they are located within different blocks. This behavior is new as of Handlebars 4, the <a href="https://github.com/wycats/handlebars.js/blob/master/release-notes.md">release notes</a> discuss the prior behavior as well as the migration plan.

  .bullet
    .description
      Handlebars also allows for name conflict resolution between helpers and
      data fields via a <code>this</code> reference:
    :html
      <p>{{./name}} or {{this/name}} or {{this.name}}</p>
    .notes
      Any of the above would cause the <code>name</code> field on the
      current context to be used rather than a helper of the same name.

%h2#comments
  Template comments with <code>{{!-- --}}</code> or <code>{{! }}</code>.

.content
  .bullet
    .description
      You can use comments in your handlebars code just as you would in your
      code. Since there is generally some level of logic, this is a good
      practice.
    :html
      <div class="entry">
        {{!-- only output author name if an author exists --}}
        {{#if author}}
          <h1>{{firstName}} {{lastName}}</h1>
        {{/if}}
      </div>
    .notes
      The comments will not be in the resulting output. If you'd like the
      comments to show up. Just use html comments, and they will be output.
    :html
      <div class="entry">
        {{! This comment will not be in the output }}
        <!-- This comment will be in the output -->
      </div>

    .notes
      Any comments that must contain <code>}}</code> or other handlebars
      tokens should use the <code>{{!-- --}}</code> syntax.

%h2#helpers
  Helpers

.content
  .bullet
    .description
      Handlebars helpers can be accessed from any context in a template.
      You can register a helper with the <code>Handlebars.registerHelper</code> method.
    :html
      <div class="post">
        <h1>By {{fullName author}}</h1>
        <div class="body">{{body}}</div>

        <h1>Comments</h1>

        {{#each comments}}
        <h2>By {{fullName author}}</h2>
        <div class="body">{{body}}</div>
        {{/each}}
      </div>

    .notes
      when using this context and helpers:

    :javascript
      var context = {
        author: {firstName: "Alan", lastName: "Johnson"},
        body: "I Love Handlebars",
        comments: [{
          author: {firstName: "Yehuda", lastName: "Katz"},
          body: "Me too!"
        }]
      };

      Handlebars.registerHelper('fullName', function(person) {
        return person.firstName + " " + person.lastName;
      });

    .notes
      results in:

    :html
      <div class="post">
        <h1>By Alan Johnson</h1>
        <div class="body">I Love Handlebars</div>

        <h1>Comments</h1>

        <h2>By Yehuda Katz</h2>
        <div class="body">Me Too!</div>
      </div>

  .bullet
    .description
      Helpers receive the current context as the <code>this</code> context
      of the function.

    :html
      <ul>
        {{#each items}}
        <li>{{agree_button}}</li>
        {{/each}}
      </ul>

    .notes
      when using this context and helpers:

    :javascript
      var context = {
        items: [
          {name: "Handlebars", emotion: "love"},
          {name: "Mustache", emotion: "enjoy"},
          {name: "Ember", emotion: "want to learn"}
        ]
      };

      Handlebars.registerHelper('agree_button', function() {
        var emotion = Handlebars.escapeExpression(this.emotion),
            name = Handlebars.escapeExpression(this.name);

        return new Handlebars.SafeString(
          "<button>I agree. I " + emotion + " " + name + "</button>"
        );
      });

    .notes
      results in:

    :html
      <ul>
        <li><button>I agree. I love Handlebars</button></li>
        <li><button>I agree. I enjoy Mustache</button></li>
        <li><button>I agree. I want to learn Ember</button></li>
      </ul>

    .notes
      If your helper returns HTML that you do not want escaped, make sure
      to return a new <code>Handlebars.SafeString</code>.

%h2#literals
  Literals

.content
  .bullent
    .description
      Helper calls may also have literal values passed to them either as parameter arguments or hash arguments. Supported literals include numbers, strings, <code>true</code>, <code>false</code>, <code>null</code> and <code>undefined</code>.

    :javascript
      {{agree_button "My Text" class="my-class" visible=true counter=4}}

%h2#partials
  Partials

.content
  .bullet
    .description
      Handlebars partials allow for code reuse by creating shared templates. Rendering this template

    :html
      <div class="post">
        {{> userMessage tagName="h1" }}

        <h1>Comments</h1>

        {{#each comments}}
          {{> userMessage tagName="h2" }}
        {{/each}}
      </div>

    .notes
      when using this partial and context:

    :javascript
      Handlebars.registerPartial('userMessage',
          '<{{tagName}}>By {{author.firstName}} {{author.lastName}}</{{tagName}}>'
          + '<div class="body">{{body}}</div>');

    :javascript
      var context = {
        author: {firstName: "Alan", lastName: "Johnson"},
        body: "I Love Handlebars",
        comments: [{
          author: {firstName: "Yehuda", lastName: "Katz"},
          body: "Me too!"
        }]
      };

    .notes
      results in:

    :html
      <div class="post">
        <h1>By Alan Johnson</h1>
        <div class="body">I Love Handlebars</div>

        <h1>Comments</h1>

        <h2>By Yehuda Katz</h2>
        <div class="body">Me Too!</div>
      </div>

    = link("Learn More: Partials", "partials.html", :class => "more-info")


%h2#builtins
  Built-In Helpers

.contents
  .bullet
    .description
      Handlebars offers a variety of built-in helpers such as the <code>if</code> conditional
      and <code>each</code> iterator.

    = link("Learn More: Built-In Helpers", "builtin_helpers.html", :class => "more-info")


%h2#Utilities
  API Reference

.contents
  .bullet
    .description
      Handlebars offers a variety of APIs and utility methods for applications and helpers.
    = link("Learn More: API Reference", "reference.html", :class => "more-info")
